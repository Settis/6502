VARIABLE TMP

: DROP ( n -- )
    TMP !
;

: DUP ( n -- n n )
    TMP !
    TMP @
    TMP @
;

: SWAP ( a b -- b a )
    TMP !
    >R
    TMP @
    R>
;

: OVER ( a b -- a b a )
    >R
    TMP !
    TMP @
    R>
    TMP @
;

: ROT ( a b c -- b c a )
    >R
    >R
    TMP !
    R>
    R>
    TMP @
;

: NOT ( n -- n )
    DUP
    NAND
;

: OR ( n n -- n )
    NOT
    >R
    NOT
    R>
    NAND
;

: AND ( n n -- n )
    NAND
    NOT
;

: XOR ( n n -- n )
    \ (NOT X OR NOT Y) AND (X OR Y)
    OVER NOT
    OVER NOT
    OR
    >R
    OR
    R>
    AND
;

: C@ ( a -- c )
    @
    FF AND
;

: C! ( c a -- )
    SWAP
    FF AND
    OVER @ FF00 AND
    OR
    SWAP 
    !
;

: IMMEDIATE ( -- )
    CONTEXT @ C@
    40 OR
    CONTEXT @ C!
;

: 1+ ( n -- n ) 1 + ;
: 2+ ( n -- n ) 2 + ;

: [
    0 STATE !
; IMMEDIATE

: ]
    C0 STATE !
;

: +! ( n addr -- ) \ increase value at addr by n
    SWAP OVER @
    + SWAP !
;

: HERE ( -- a )
    DP @
;

: ALLOT ( n -- )
    DP +! \ Increment dictionary pointer DP by n, reserving n bytes of
          \ dictionary memory for whatever purposes intended.
;

: C, ( b -- )
    HERE C! 
    1 ALLOT
;

: MINUS ( n -- -n) \ change sign
    NOT 1+
;

: - ( n n -- n ) \ subtract
    MINUS +
;

: 1- ( n -- n ) 1 - ;

VARIABLE (ERROR)

: ?ERROR ( f n -- )
    SWAP
    ( IF ) 0BRANCH [ HERE 0 , ] 
        (ERROR) @ EXECUTE
    ( ELSE ) BRANCH [ HERE 0 , SWAP ] [ HERE OVER - SWAP ! ]
        DROP
    ( ENDIF ) [ HERE OVER - SWAP ! ]
;

: ?COMP
    STATE @
    0=
    11 ?ERROR
;

: ?PAIRS ( n n -- )
    -
    13 ?ERROR
;

: COMPILE ( -- )
    ?COMP     \ Error if not compiling
    R>        \ Top of return stack is pointing to the next word following
    DUP 2+ >R \ Increment this pointer by 2 to point to the second word following
              \ COMPILE , which will be the next word to be executed. The word
              \ immediately following COMPILE should be compiled, not executed.
    @ ,       \ Do the compilation at run-time.
;

\ creating BRK for debug
0 CONSTANT BRK HERE 2 - HERE 4 - !

: -FIND
    (WORD)
    HERE
    CONTEXT @
    (FIND)
;

: CFA ( pfa -- cfa ) 2 - ;

: [COMPILE] ( -- )
    -FIND       \ Accept next text string and search dictionary for a match.
    0= 0 ?ERROR \ No matching entry was found. Issue an error message.
    DROP        \ Discard the length byte of the found name.
    CFA ,       \ Convert the name field address to code field address and compile it into
                \ the dictionary.
; IMMEDIATE

: IF ( f -- ) \ at run-time
     ( -- addr n ) \ at compile time
    COMPILE 0BRANCH \ Compile the code field address of the run-time routine 0BRANCH into the
                    \ dictionary when IF is executed.
    HERE            \ Push dictionary address on stack to be used by ELSE or ENDIF to calculate
                    \ branching offset.
    0 ,             \ Compile a dummy zero here, later it is to be replaced by an offset value
                    \ used by 0BRANCH to compute the next word address.
    2               \ Error checking number.
; IMMEDIATE         \ IF in a colon definition must be executed, not compiled.

: ENDIF ( addr n -- ) \ at compile time
    ?COMP          \ Issue an error message if not compiling.
    2 ?PAIRS       \ ENDIF must be paired with IF or ELSE . If n is not 2, the structure was
                   \ disturbed or improperly nested. Issue an error message.
    HERE           \ Push the current dictionary address to stack.
    OVER -         \ HERE-addr is the forward branching offset.
    SWAP !         \ Store the offset in addr , thus completing the IF-ENDIF or IF-ELSE-ENDIF
                   \ construct.
; IMMEDIATE

: ELSE ( addr1 n1 -- addr2 n2 ) \ at compile time
    2 ?PAIRS        \ Error checking for proper nesting.
    COMPILE BRANCH  \ Compile BRANCH at run-time when ELSE is executed.
    HERE            \ Push HERE on stack as addr2 .
    0 ,             \ Dummy zero reserving a cell for branching to ENDIF .
    SWAP            \ Move addr1 to top of stack.
    2               \ I need to put 2 here for check inside ENDIF
    [COMPILE] ENDIF \ Call ENDIF to work on the offset for forward branching. ENDIF is an
                    \ immediate word. To compile it the word [COMPILE] must be used.
    2               \ Leave n2 on stack for error checking.
; IMMEDIATE

: BEGIN ( -- addr n ) \ at compile time
    ?COMP \ Issue an error message if not compiling.
    HERE  \ Push dictionary pointer on stack to be used to compute backward branching offset.
    1     \ Error checking number.
; IMMEDIATE

: BACK ( addr -- )
    HERE - , \ Compile addr-HERE, the backward branching offset.
;

: UNTIL ( addr n -- ) \ at compile time
    1 ?PAIRS        \ If n is not 1, issue an error message.
    COMPILE 0BRANCH \ Compile 0BRANCH at run-time.
    BACK            \ Compute backward branching offset and compile the offset.
; IMMEDIATE

: AGAIN ( addr n -- ) \ at compile time
    1 ?PAIRS       \ Error checking.
    COMPILE BRANCH \ Compile BRANCH and an offset to BEGIN .
    BACK
; IMMEDIATE

: WHILE ( addr1 n1 -- addr1 n1 addr2 n2 n3 ) \ at compile time
    [COMPILE] IF \ Call IF to compile 0BRANCH and the offset.
    4            \ Leave 4 as n2 to be checked by REPEAT.
; IMMEDIATE

: REPEAT ( addr1 n1 addr2 n2 n3 -- ) \ at compile time
    4 ?PAIRS        \ Error checking for WHILE
    >R >R           \ Get addr2 and n2 out of the way.
    [COMPILE] AGAIN \ Let AGAIN do the dirty work of compiling an unconditional branch back to BEGIN .
    R> R>           \  Restore addr2 and n2 .
    [COMPILE] ENDIF \  Use ENDIF to resolve the forward branching needed by WHILE .
; IMMEDIATE

: = ( n n -- f )
    - 0=
;

: 0< ( n -- f )
    8000 AND 0= NOT
;

: < ( n n -- f )
    - 0<
;

: > ( n n -- f )
    SWAP <
;

: CR 
    D EMIT
;

: SPACE
    20 EMIT
;

: R ( -- n )
    R> R> DUP >R SWAP >R
;

VARIABLE _R

: (DO) ( n1 n2 -- )
    R> _R !  \ return address
    SWAP
    >R >R
    _R @ >R \ put back return address
;

: DO ( n1 n2 -- ) \ at runtime
     ( -- addr n ) \ at compile time
    COMPILE (DO) \ Compile the run-time routine address of (DO) into dictionary.
    HERE         \ Address addr for backward branching from LOOP or +LOOP.
    3            \ Number for error checking.
; IMMEDIATE

: I ( -- I )
    R> _R !  \ return address
    R>
    DUP
    >R
    _R @ >R \ put back return address
;

: LEAVE ( -- )
    R> _R !  \ return address
    R> DROP
    R> DUP
    >R >R
    _R @ >R \ put back return address
;

: (+LOOP)
    R> _R !  \ return address

    R> + R>
    DUP >R
    SWAP DUP >R

    > NOT DUP
    IF
        R> DROP
        R> DROP
    ENDIF
    _R @ >R \ put back return address
;

: (LOOP)
    R> _R !  \ return address

    R> R>
    DUP >R
    SWAP 1+
    DUP >R

    > NOT DUP
    IF
        R> DROP
        R> DROP
    ENDIF
    _R @ >R \ put back return address
;

: LOOP ( addr n -- ) \ at runtime
    3 ?PAIRS \ Check the number left by DO . If it is not 3, issue an error message.
             \ The loop is not properly nested.
    COMPILE (LOOP)
    COMPILE 0BRANCH
    BACK
; IMMEDIATE

: +LOOP 
    3 ?PAIRS \ Check the number left by DO . If it is not 3, issue an error message.
             \ The loop is not properly nested.
    COMPILE (+LOOP)
    COMPILE 0BRANCH
    BACK 
; IMMEDIATE

: . ( n -- )
    4 0 DO
        DUP
        0F AND
        SWAP
        2/ 2/ 2/ 2/
    LOOP
    DROP
    4 0 DO
        DUP
        A < IF
            30
        ELSE
            37
        ENDIF
        + EMIT
    LOOP
    SPACE
;

: COUNT ( addr1 -- addr2 n )
    DUP 1+  \ addr2=addr1+1
    SWAP    \ Swap addr1 over addr2 and
    C@      \ fetch the byte count to the stack.
;

: -DUP DUP IF DUP ENDIF ;

: TYPE ( addr n - )
    -DUP            \ Copy n if it is not zero.
    IF              \ n is non-zero, do the following.
        OVER +      \ addr+n, the end of the text
        SWAP        \ addr, start of text
        DO          \ Loop to type n characters
            I C@    \ Fetch one character from text
            EMIT    \ Type it out
        LOOP
    ELSE            \ n=0, no output necessary.
        DROP        \ Discard addr
    ENDIF
;

: ENCLOSE ( addr c -- addr n1 n2 n3 )
    >R          \ addr on the stack
    0 OVER      \ addr n1 addr
    BEGIN
        DUP C@   \ addr n1 addr content
        R =
    WHILE
        1+ SWAP
        1+ SWAP
    REPEAT

    >R DUP R>   \ addr n1 n2 addr+n1
    BEGIN
        DUP C@ DUP
        0= SWAP
        R =
        OR NOT
    WHILE \ it's not a separator and not a 0
        1+ SWAP
        1+ SWAP
    REPEAT
    >R DUP R>   \ addr n1 n2 n3 addr+n2
    BEGIN
        DUP C@
        R =
    WHILE
        1+ SWAP
        1+ SWAP
    REPEAT

    R> DROP DROP
;

: CMOVE ( from to u -- )
    0 DO
        OVER C@
        OVER C!
        1+ SWAP
        1+ SWAP
    LOOP
    DROP DROP
;

: FILL ( addr n b -- )
    SWAP >R \ store n on the return stack
    OVER C! \ store b in addr
    DUP 1+  \ addr+1, to be filled with b
    R> 1-   \ n-1, number of butes to be filled by CMOVE
    CMOVE   \ A primitive. Copy (addr) to (addr+1), (addr+1) to (addr+2),
            \ etc, until all n locations are filled with b.
;

: ERASE 0 FILL ;
20 CONSTANT BL
: BLANKS BL FILL ; 

: WORD ( c -- )
    \ BLK check is disabled
    TIB @           \ read from terminal input buffer
    IN @            \ IN contains the character offset into the current input text buffer.
    +               \ Add offset to the starting address of buffer, pointing to the next
                    \ character to be read in.
    SWAP            \ Get delimiter c over the string address.
    ENCLOSE         \ A primitive word to scan the text. From the byte address and the
                    \ delimiter c , it determines the byte offset to the first non-delimiter
                    \ character, the offset to the first delimiter after the text string,
                    \ and the offset to the next character after the delimiter. If the
                    \ string is delimited by a NUL , the last offset is equal to the previous
                    \ offset.
                    \ ( addr c --- addr n1 n2 n3 )
    HERE 22 BLANKS  \ Write 34 blanks to the top of dictionary.
    1+              \ !!! this is a hack for working with bootstrap parser
    IN +!           \ Increment IN by the character count, pointing to the next text string to
                    \ be parsed.
    OVER - >R       \ Save n2-n1 on return stack.
    R HERE C!       \ Store character count as the length byte at HERE .
    +               \ Buffer address + nl, starting point of the text string in the text
                    \ buffer.
    HERE 1+         \ Address after the length byte on dictionary.
    R>              \ Get the character count back from the return stack.
    CMOVE           \ Move the string from input buffer to top of dictionary.
;

: (.") ( -- )
    R       \ Copy EP from the return stack, which points to the beginning of the in-
            \ line text string.
    COUNT   \ Get the length byte of the string, preparing for TYPE.
    DUP 1+  \ Length+1
    R> + >R \ Increment EP on the return stack by length+l, thus skip the text string
            \ and point to the next word after ", which is the next word to be
            \ executed.
    TYPE    \ Now type out the text string.
;

: ." ( -- )
    22                  \ hex ASCII value of the delimiter ".
    STATE @             \ Compiling or executing?
    IF                  \ Compiling state
        COMPILE (.")    \ Compile the code field address of (") so it will type out text at runtime.
        WORD            \ Fetch the text string delimited by " , and store it on top of dictionary,
                        \ in-line with the compiled addresses.
        HERE C@         \ Fetch the length of string
        1+ ALLOT        \ Move the dictionary pointer parsing the text string. Ready to compile the
                        \ next word in the same definition.
    ELSE                \ Executing state
        WORD            \ Get the text to HERE , on top of dictionary.
        HERE            \ Start of text string, ready to be typed out.
        COUNT TYPE
    ENDIF
; IMMEDIATE

: ERR ( n -- )
    F0EF F0 !
    F0   F2 !
         F4 !
    BRK
;

\ put ERR link to (ERROR)
-FIND ERR DROP DROP CFA (ERROR) !

." Some thing"

: TEST
    ." Foo bar"
;

TEST

\ TODO: during cold reinitialize TIB to the proper value
